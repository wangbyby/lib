- 索引建立 底层原理 聚簇非聚簇 是否回表

    create index on table1(col1);

    B+树, hash

  - 找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。
  - 非聚簇: 索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引。


- 最左匹配原则 联合索引 给一个where 里面有 > 和groupby orderby 问是否出发索引

在 InnoDB 中联合索引只有先确定了前一个（左侧的值）后，才能确定下一个值。如果有范围查询的话，那么联合索引中使用范围查询的字段后的索引在该条 SQL 中都不会起作用

发出, 建立多列索引, 选择性高的字段放在前面

- SQL执行过程

客户端: sql语句发给服务端

服务端: 
    1. 接受sql语句, 解析, 优化, 执行器, 存储引擎(缓存池 或者 磁盘)
    2. 写入undo log文件
    3. 更新在Buffer pool中完成, 将更新后的数据写入redo log buffer
    4. 提交事务
        1. redo log buffer写入redo log中
        2. 本地操作记录到bin log中
        3. 将bin log文件名字和更新内容在bin log位置写入redo log中
        4. 同时添加4. commit标记


- Mysql包括哪几部分
    连接池
    sql 解析器,优化器,执行器
    存储引擎, 物理文件
    数据库管理系统

- MYSQL如何解决幻读？ MVCC通过什么实现，除了幻读还解决了什么问题

幻读指的是`在一个事务内，同一SELECT语句在不同时间执行，得到不同的结果集时`，就会发生所谓的幻读问题。

MVCC: 行锁结合行的多个版本



- innodb与myisam

   InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 

   InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； 

   InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

    MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
    也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。

- 慢sql优化。 如何查看是否命中索引 explain返回参数需要关注哪个

    mysql查看是否使用索引，简单的看type类型就可以。如果它是all，那说明这条查询语句遍历了所有的行，并没有使用到索引。

    type, rows, filtered, extra

- 有MYSQL为什么用mongo，mongo特点，列可扩展，Mongo 索引用什么数据结构

    - 易伸缩，自动故障转移。易伸缩指的是提供了分片能力，能对数据集进行分片，数据的存储压力分摊给多台服务器。自动故障转移是副本集的概念，MongoDB能检测主节点是否存活，当失活时能自动提升从节点为主节点，达到故障转移。
    - 数据模型因为是面向对象的，所以可以表示丰富的、有层级的数据结构
    - B tree

- 为什么用ES: 搜索引擎
  搜索aba。 mysql无法实现

全文检索，倒排索引：采用分词的方式。 手机壳 -〉手机 手 壳 手机壳

- 查询语句为 select * from x where %x x%. 模糊匹配有通配符，索引失效 慢



- nosql 特点
    1、容易扩展；2、大数据量、高性能；3、灵活的数据模型；4、高可用

- redis 为什么快
  - 内存操作 IO少
  - 多路复用 epoll
  - 非阻塞IO

IO多路复用: 单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力

- 如何持久化 RDB AOF

    - 多进程COW
    - AOF 日志记录了自 Redis 实例创建以来所有的修改性指令序列，那么就可以通过对一个空的 Redis 实例顺序执行所有的指令，也就是「重放」，来恢复 Redis 当前实例的内存数据结构的状态。

- Redis 主从架构数据同步

Redis 提供了主从模式，通过主从复制，将数据冗余一份复制到其他 Redis 服务器。

`面试官：主从之间数据如何保证一致性？`
为了保证副本数据的一致性，主从架构采用了读写分离的方式。
  - 读操作：主、从库都可以执行；
  - 写操作：主库先执行，之后将写操作同步到从库；

- 缓存淘汰策略

- redis 数据结构 及底层实现 及常用场景

    - string: SDS简单动态字符串
    - list  : ziplist, quicklist = ziplist+linklist: 
    - hash
    - set
    - sortset: 跳表

- redis事务与mysql事务不同点

    redis: 
    1. 单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断；
    2. 没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题；
    3. 不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，**没有回滚**；
    redis实现事务，是基于commands队列；
    - 如果没有开启事务，command将会被立即执行并返回执行结果，并且直接写入磁盘；
    - 如果事务开启，command不会被立即执行，而是排入队列，并返回排队状态（具体依赖于客户端（例如：spring-data-redis）自身实现）。调用exec才会执行commands队列
    (用multi、exec、discard，显式开启并控制一个Transaction)


    mysql: mysql实现事务，是基于undo/redo日志；
    - undo记录修改前状态，rollback基于undo日志实现；
    - redo记录修改后的状态，commit基于redo日志实现；
    - 在mysql中无论是否开启事务，sql都会被立即执行并返回执行结果，只是事务开启后执行后的状态只是记录在redo日志，执行commit之后，数据才会被写入磁盘；

- 缓存击穿，雪崩, 穿透

缓存雪崩: 
    缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重.
    解决: 分散失效时间

缓存击穿: 
    对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。
    解决: 互斥锁; 不过期 

缓存穿透:
    是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

    解决: 布隆过滤器; 缓存为空结果