1.
func main() {
	a := []int{3, 2, 4}
	fmt.Println(twoSum(a, 6))
}

func twoSum(nums []int, target int) []int {
	var a = make([]int, 2)
	for i := 0; i < len(nums); i++ {
		for j := i; j < len(nums); j++ {
			if nums[i]+nums[j] == target && i != j {
				a[0], a[1] = i, j

				return a
			}
		}
	}
	return a
}
2.
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	p1 := l1
	p2 := l2
	c := 0
	for p1.Next != nil && p2.Next != nil {
		tmp := p1.Val + p2.Val + c
		c = tmp / 10
		p1.Val = tmp % 10
		fmt.Println(p1.Val)
		p1 = p1.Next
		p2 = p2.Next
	}
	tmp := p1.Val + p2.Val + c
	c = tmp / 10
	p1.Val = tmp % 10
	if p1.Next == nil && p2.Next == nil {
		if c > 0 {
			a := &ListNode{}
			a.Next = nil
			a.Val = c
			p1.Next = a
		}
		return l1
	}
	if p1.Next == nil {
		p1.Next = p2.Next
	}
	p1 = p1.Next
	tail := p1
	for p1 != nil {
		tmp := p1.Val + c
		c = tmp / 10
		p1.Val = tmp % 10
		if p1.Next == nil {
			tail = p1
		}
		p1 = p1.Next
	}
	if c > 0 {
		a := &ListNode{}
		a.Next = nil
		a.Val = c
		tail.Next = a
	}
	return l1

}
3.
func lengthOfLongestSubstring(s string) int {
	m := make(map[byte]int)
	lenM := 0
	maxlen := lenM
	for i := 0; i < len(s); i++ {
		index, ok := m[s[i]]
		if ok {
			for k, v := range m {

				if v <= index {
					if maxlen < lenM {
						maxlen = lenM
					}
					delete(m, k)
					lenM--
				}
			}
			m[s[i]] = i
			lenM++
		} else {
			m[s[i]] = i
			lenM++
		}

	}
	if maxlen < lenM {
		maxlen = lenM
	}
	return maxlen
}
4.两个数组的中位数
思想
	对比两个数组k/2位置元素大小
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	l1 := len(nums1)
	l2 := len(nums2)
	left := (l1 + l2 + 1) / 2
	right := (l1 + l2 + 2) / 2
	res := (do(nums1, 0, l1-1, nums2, 0, l2-1, left) + do(nums1, 0, l1-1, nums2, 0, l2-1, right))

	return float64(res) / 2
}

func do(nums1 []int, s1 int, e1 int, nums2 []int, s2 int, e2 int, k int) int {
	l1 := e1 - s1 + 1
	l2 := e2 - s2 + 1
	if l1 > l2 {
		return do(nums2, s2, e2, nums1, s1, e1, k)
	}
	if l1 == 0 {
		return nums2[s2+k-1]
	}
	if k == 1 {
		return min(nums1[s1], nums2[s2])
	}
	i := s1 + min(l1, k/2) - 1
	j := s2 + min(l2, k/2) - 1
	if nums1[i] > nums2[j] {
		return do(nums1, s1, e1, nums2, j+1, e2, k-(j-s2+1))
	} else {
		return do(nums1, i+1, e1, nums2, s2, e2, k-(i-s1+1))
	}
}
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

最长回文串
	动态规划
	Manacher算法
		func longestPalindrome(s string) string {
			lens := len(s)
			if lens < 2 {
				return s
			}
			sa := "$#"
			for _, v := range s {
				sa += string(v) + "#"
			}
		
			lensa := len(sa)
			saNum := make([]int, lensa)
			maxindex, maxNum := 0, 0
			for i, _ := range sa {
				if i <= 1 {
					continue
				}
				left := i - 1
				right := i + 1
		
				for 0 < left && right < lensa && sa[left] == sa[right] {
					saNum[i]++
					left--
					right++
				}
		
				if saNum[i] > maxNum {
					maxNum = saNum[i]
					maxindex = i
				}
		
			}
			log.Println(saNum)
			log.Println(maxindex, maxNum)
			res1 := sa[maxindex-saNum[maxindex] : maxindex+saNum[maxindex]+1]
			log.Println(res1)
			res2 := ""
			for _, v := range res1 {
				if v != '#' {
					res2 += string(v)
				}
			}
			return res2
		
		}
		
Z字形变换
import (
	"fmt"
	"strings"
)

func convert(s string, numRows int) string {

	apps := s
	k := numRows - 1
	width := k * 2
	ls := len(s)
	if ls < 3 || numRows <= 1 {
		return s
	}
	if ls%width != 0 {
		appl := (ls/width + 1) * width
		for i := ls; i < appl; i++ {
			apps += "$"
		}
	}

	res := make([]string, numRows)
	for i := 0; i < len(apps); i += width {
		for j := 0; j < numRows; j++ {
			if j != 0 && j != k {
				tmp := string(apps[i+j]) + string(apps[i-j+width])
				res[j] += tmp

			} else {
				res[j] += string(apps[i+j])
			}
		}
	}
	resr := ""
	for _, v := range res {
		resr += v
	}

	return strings.Replace(resr, "$", "", -1)
}
反转整数
func reverse(x int) int {
	flag := true
	if x == 0 {
		return x
	} else if x < 0 {
		flag = false
		x = 0 - x
	}
	s := strconv.Itoa(x)
	sr, _ := strconv.Atoi(reverseStr(s))
	if !flag {
		sr = -sr
	}
	if sr > 1<<31-1 || sr < -1<<31 {
		return 0
	}
	return sr
}
func reverseStr(str string) string {
	var result string
	strLen := len(str)
	for i := 0; i < strLen; i++ {
		result = result + fmt.Sprintf("%c", str[strLen-i-1])
	}
	return result
}

myAtoi
	func myAtoi(s string) int {
		num := 0
		i := 0
		k := 1
		numK := 0
		for _, v := range s {
			if !le(v) {
				if num == 0 {
					return 0
				} else {
					break
				}
			}
			if v == ' ' {
				if num != 0 || i > 0 {
					break
				}
				if numK != 0 {
					return 0
				}
			}
			if v == '+' || v == '-' {
				if numK != 0 {
					return 0
				}
				if v == '-' {
					k = -1
				}
				numK++
			} else {
				if isNum(v) {
					num = 10*num + int(v) - 48
					i++
				}
			}
		}
		num = k * num
	
		fmt.Println(num)
		if num < -1<<31 {
			if k == 1 {
				return 1<<31 - 1
			}
			return -1 << 31
		}
		if num > 1<<31-1 {
			return 1<<31 - 1
		}
		return num
	}
	func isNum(v rune) bool {
		if 48 <= v && v <= 57 {
			return true
		}
		return false
	}
	func le(v rune) bool {
		if (48 <= v && v <= 57) || v == '+' || v == '-' || v == ' ' {
			return true
		}
		return false
	}
	正则表达式匹配
	func isMatch(s string, p string) bool {
		sl, pl := len(s), len(p)
		if pl == 0 {
			return sl == 0
		}
		if pl > 1 && p[1] == '*' {
			return isMatch(s, p[2:]) || (sl != 0 && (s[0] == p[0] || p[0] == '.') && isMatch(s[1:], p))
		} else {
			return sl != 0 && (s[0] == p[0] || p[0] == '.') && isMatch(s[1:], p[1:])
		}
	}
	// var star error = errors.New("*")
	// var matchnum int
	
	// //匹配子字符串
	// func isMatch(s string, p string) bool {
	// 	//边界判断
	
	// 	m := valid(p)
	// 	n := len(s)
	// 	fmt.Println("m=", m, "len s=", n)
	// 	q := 0
	// 	f, err := trans(p)
	// 	if err != nil {
	// 		return false
	// 	}
	// 	i := 0
	// 	for i < n {
	// 		v := rune(s[i])
	// 		q, err = boxTrans(f, q, v)
	// 		if err == star {
	// 			continue
	// 		}
	// 		i++
	// 		fmt.Println("i=", i)
	// 		fmt.Println("matchnum=", matchnum)
	// 		if err != nil {
	// 			log.Println(err)
	// 			return false
	// 		}
	// 		if q == m {
	// 			return true
	// 		}
	
	// 	}
	// 	return false
	// }
	
	// func valid(p string) int {
	// 	k := 0
	// 	for _, v := range p {
	// 		if v != '*' {
	// 			k++
	// 		}
	// 	}
	// 	return k
	// }
	
	// type node struct {
	// 	status int
	// 	char   rune
	// }
	
	// func trans(p string) (f map[int]map[rune]node, err error) {
	// 	f = make(map[int]map[rune]node)
	// 	k := 0
	// 	for i, v := range p {
	// 		if v == '*' {
	// 			if i > 0 {
	// 				tmp := make(map[rune]node)
	// 				tmp[rune(p[i-1])] = node{status: k - 1, char: '*'} //k - 1
	// 				f[k] = tmp
	
	// 			} else {
	// 				return nil, errors.New("invalid pattern")
	// 			}
	// 		} else {
	// 			if _, ok := f[k]; !ok {
	// 				tmp := make(map[rune]node)
	// 				tmp[v] = node{status: k + 1}
	// 				f[k] = tmp
	// 			}
	
	// 			f[k][v] = node{status: k + 1}
	// 			k++
	
	// 		}
	// 	}
	// 	return
	// }
	
	// func boxTrans(f map[int]map[rune]node, a int, b rune) (c int, err error) {
	// 	fmt.Printf("inbox= %v %v%c\n", a, b, b)
	// 	fa, ok := f[a]
	// 	if !ok {
	// 		return 0, errors.New("A none state")
	// 	}
	// 	v, ok := fa['.']
	// 	if ok {
	// 		matchnum++
	// 		return v.status, nil
	// 	}
	
	// 	v, ok = fa[b]
	
	// 	if !ok {
	// 		for _, val := range f[a+1] {
	// 			//fmt.Println(f[a+1])
	// 			if val.char == '*' {
	
	// 				return a + 1, star
	// 			}
	// 		}
	// 		fmt.Printf("err%v %v%c\n", a, b, b)
	// 		return 0, errors.New("B none state")
	// 	}
	// 	matchnum++
	// 	return v.status, err
	
	// }
	
	
	
