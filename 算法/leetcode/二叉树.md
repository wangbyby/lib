leetcode二叉树探索

# 前序遍历
# 中序遍历
# 后序遍历
# 层次遍历

今天刷了该标签的题, 自己速度还是慢, 不过总结一下经验分享给大家.

该标签所有的题都围绕着四个遍历.
特别是用**递归**遍历二叉树,一定要牢牢掌握.

## 套路如下
```python
    def visit(node){
        //前序
        visit(node.left)
        //中序
        visit(node.right)
        //后序
    }
```
感觉有点简单? 你细品. 什么问题是三选一,什么问题是全都要呢? 

首先要把``树与递归``牢牢联系起来,

|题|遍历方法|
|:-:|:-:|
|最大深度|后序遍历|
|路径总和|前序|
|从中序和后序构造二叉树|前序|
|序列化与反序列化|前序|
|填充右侧节点|层次|

**前序遍历是不是用的很多?**
为啥呢? 前序是不是跟``DFS(深度优先)``一样? 先看看自己,然后去左子树,不行了去右子树.
~~其实我也不知道他为啥那么多~~
既然``DFS``出现的多, 那就自己列一个小表.
1. 先前序遍历``DFS``
2. 后序遍历
3. 层次遍历``BFS``
4. 中序遍历
5. 混合
看到二叉树的题,就挨个对一遍. 

先不考虑边界条件,
然后把条件往里面填不就好了,
```
    def visit(node){
        //1.前序
        visit(node.left)
        //2.中序
        visit(node.right)
        //3.后序
    }
```
- 一般判断节点是不是``None``和构造新节点在``1.``,
- 几乎没有东西放在``2.``,
- 比大小的,返回真假的在``3.``.

至于层次遍历, 运用队列先进先出, 控制好每层个数不就好了.

有人会说递归性能不好, 没有迭代nb,``u1s1``确实,
但是
# 切记``过早优化是万恶之源``
先写出来能跑的, 再跑对, 之后积累大量经验再说优化.
