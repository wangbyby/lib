
``linux的物理内存管理``
1. 分段
   1. 首次
   2. 最佳适应
   3. 最坏适应
2. 分页


# 储存管理器

- 程序开始执行时,堆区是一个连续的空闲空间单元
- 随着程序``分配和回收``的进行, 空间被分割成若干空闲块和已用块,
-  而空闲块不一定位于堆区的某个连续区域中


# gc

gc找到``不可达``对象, 并将这些对象交给跟踪空闲空间的储存管理器, 收回他们所占的空间

- 基本要求: 类型安全  动态/静态
- 根集: 不需要任何指针解引用就可被直接访问的数据称为根集.
  - ``递归``的, 对于任意一个对象, 如果指向它的一个引用被保存在任何可达对象的字段或数组元素中, 那么这个对象本身也是可达的.
  - 参数传递和赋值会传递可达性
  - 赋值和过程结束可能结束对象的可达性
- 寻找不可达对象的基本方法
  - 捕获对象变得不可达的转变时刻
    - 引用计数``近似实现``
  - 周期性定位所有可达对象, 然后推出其他对象都是不可达的
    - 基于跟踪

1. 引用计数垃圾回收器

- 当一个对象从可达转变为不可达的时候, 改回收器可以将该对象确认为垃圾; 当一个对象的引用计数为0时, 该对象就会被删除.
- 维护
  - 对象分配: 新对象的引用计数设置为1
  - 参数传递: 被传递给一个过程的每个对象的引用计数+1
  - 引用赋值. 如果u,v都是引用, 对于``u=v``, v指向对象的引用计数+1, u本来指向的-1
  - 过程返回: 一个过程退出时, 该过程活动记录的局部变量指向的对象的引用数``必须``-1. 如多个局部变量存放了指向同一对象的引用, 那么对每个这样的引用, 该对象的引用计数都要-1
  - 可达性传递丢失: 当一个对象的引用计数为0时, 必须将该对象中的各个引用所指向的每个对象的引用计数-1
- 缺点:
  - 不能回收不可达的循环数据结构
  - 开销大
- 改进: 延期引用计数
- 优点: 增量垃圾回收, 较低的空间使用量
- 适用于 交互式系统


基于跟踪的回收
---

周期性运行, 在空闲空间被耗尽或者低于阈值时启动

2. 基本的标记-清扫

``直接全面停顿的算法``

算法
- 输入: 根集, 堆, Free``包含堆中所有未分配储存块的空闲空间列表``
- 输出: 删除了所有垃圾之后的经过修改的Free列表
- 列表Free: 已知的空闲对象
- 列表Unscanned: 确定可达的对象, 当没有考虑后续对象的可达性



- 标记阶段
  - init: 被根集引用的每个对象的reached位设置为1, 加入到Unscanned列表中
  - while $Unscanned \neq \emptyset$
    - 从Unscanned列表删除某个对象o
    - for 在o中引用的每个对象o'
      - if o'尚未被访问到, 即它的reached位为0
        - 将o'的reached位设置为1
        - 将o'放到Unscanned中
- 清扫阶段
  - $Free=\emptyset$
  - for 堆区的每个内存块o //高代价
    - if o尚未被访问到, 即它的reached位为0
      - 将o加入Free中
    - else
      - 将o的reached位设置为0


3. Baker 用列表记录所有已分配对象, 就不去检查整个堆区

- 列表Free: 已知的空闲对象
- 列表Unreached: 未被访问
- Unscanned: 待扫描
- Scanned: 已扫描

- 算法
  - $Scanned = \emptyset$
  - Unscanned = 在根集中引用的对象集合, 并将这些对象从Uneached中删除
  - while $Unscanned \neq \emptyset$
    - 将对象从Unscanned移动到Scanned
    - for o中引用的每个对象o'
      - if o'在Unreached中
        - 将o'从Unreached移动到Unscanned中
  - $Free=Free \cup Unreached$
  - $Unreached=Scanned$


3. 标记并压缩. 移动可达对象以消除存储碎片

- NewLocation表
- 算法
  - Unscanned= 根集引用对象的集合
  - while $Unscanned \neq \emptyset$
    - 从Unscanned中移除对象o
    - for 在o中引用的每个对象o'
      - if o'未被访问
        - 将o'标记为已访问的
        - 将o'加入到列表Unscanned中
  - //计算新位置
  - free = 堆区开始位置
  - for 从低端开始,遍历堆区每个储存块o
    - if o是已被访问的
      - NewLocation(o)=free
      - free = free+sizeof(o)
  - //重新设置引用目标并移动已被访问的对象
  - for 从低端开始, 堆区中每个存储块o
    - if o是已被访问的
      - for o中每个引用o.r
        - o.r = NewLocation(o.r)
      - 将o拷贝到NewLocation(o)
  - for 根集的每个引用r
    - r = NewLocation(r)

