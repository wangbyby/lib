# 前言

学习Progamming Rust这本书的笔记.



首先Rust是一个系统语言, 啥是系统语言? 或者说系统语言针对什么?

- OS
- 设备驱动
- 文件系统
- 数据库
- 硬件
- 密码学
- 流媒体
- 网络
- 容器,虚拟机
- 等等

好多哦,基本上底层的都涵盖了. 或者说系统编程语言在资源有限环境下工作.要榨干内存的每个单元和CPU的每个周期.

那Rust能干什么, 解决困扰了工业界多年的问题. 都有啥? 且听本书娓娓道来.

## 本书的组成

- 好好看完前五章: 基本类型, 所有权, 引用

- 六到十章可以跳着看: 表达式, **错误处理**, 模块, 结构体, 枚举与模式匹配

  不要忘掉错误处理!!!

- 十一到十三章也要好好看:trait和泛型, trait下的操作符重载和很多使用的trait

  - 读完十一章之后,就有闭包和迭代器

- 剩下的就是集合, 文本, 输入输出, 并发, 宏, 以及黑魔法unsafe



好啦, 开始第一章: 为啥用Rust?

为啥? 为啥不用C/C++... 好像大家都喜欢骂CXX.. 但是CXX从未被超越. 写CXX的大概是人形编译器吧.

## 1. 未解决的问题

- 安全代码不好写. 啥是安全代码? C/C++想要正确管理内存特别难. 从1988年的蠕虫病毒, 大家都饱受折磨. 是兰德里的苦楚哒!
- 多线程代码好难写! 但是多线程是榨干现代硬件的唯一办法. 多线程bug还不好稳定复现, 死锁折磨人.

Rust来啦, 一个安全且多线程的语言, 性能和C/C++差不多哦. 听起来好像天上掉馅饼哦. 

Rust能让开发者控制内存, 搭起语言特性和机器的桥梁, 管控好代码的花销. 而且还有零成本抽象.

芜湖,起飞🚀!

秘诀就是编译期的**所有权, 移动语义和借用**和精心设计的静态类型系统. 讲个笑话,Rust的编译时间😁

- 所有权系统为每个变量建立了清晰的生命周期系统, gc你的替身最没用啦, 并且有健全且灵活的接口来管理其他资源,比如说socket和文件. 

  生命周期, 啊这, 周期性体现在哪里呢?好像没有哦. 应该叫生命时长😜. 我现在的理解就是, 直线, 圆圈.

- 移动语义将值在所有者之间转移
- 借用在不影响所有权的情况下暂时使用值

- 并发也建立在所有权系统上, 用一下就知道好不好用

## 2. 类型安全

啥是类型安全`type safe`? 概念不好把握. 

那在实践中啥最不安全? 

当然是**未定义行为**哒!

那先从Rust解决未定义行为入手吧.

- 啥是未定义行为? C99有

  > behavior, upon use of a nonprotable or erroneous program construct or of erroneous data, for which this International Standard imposes no requirements

  垃圾程序和垃圾数据, 执行起来也不知道是个啥.

```c


int main(){
    int a[1] = {0};
    a[1] = 0xff20cB;
    a[1<<32] = 0xff20cB;
    return 0;
}

```

Devc++运行啥也不说...

但是如果报错了, 不让执行这些垃圾代码,那就是良好定义行为. 即程序中不允许执行未定义行为,即`well defined`, 如果语言处处是`well defined`的话, 就是`type safe`的.

## 3. 总结

- 性能快
- type safe并且Rust确保数据安全且有意义
- 良好的并发,多线程支持
- trait和带trait的泛型

全村的希望就是Rust哒