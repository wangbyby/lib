
# [Copy 和 Clone 两者的区别和联系有](https://zhuanlan.zhihu.com/p/21730929)

~~生命周期-->move语义~~.**Clone来显示指定资源的流向.**

有些类型在move语义下仅仅拷贝, 有些类型是所有权转移. 而且针对``int, bool, 数组...``在栈上, 不必去考虑生命周期. 但``Vec,String等``在堆上, 需考虑生命周期. 

1. Copy内部没有方法，Clone内部有两个方法。
2. 用法
   1. **Copy trait 是给编译器用的**，告诉编译器这个类型默认采用 copy 语义，而不是 move 语义。
   2. Clone trait 是给程序员用的，我们必须手动调用clone方法，它才能发挥作用。
3. 实现
   1. Copy trait不是你想实现就实现，它对类型是有要求的，有些类型就不可能 impl Copy``例如: String``。
   2. Clone trait 没有什么前提条件，任何类型都可以实现``unsized 类型除外``。
4. Copy trait规定了这个类型在执行变量绑定、函数参数传递、函数返回等场景下的操作方式。即这个类型在这种场景下，必然执行的是``简单内存拷贝``操作，这是由编译器保证的，程序员无法控制。
5. Clone trait 里面的 clone 方法究竟会执行什么操作，则是取决于程序员自己写的逻辑。一般情况下，clone 方法应该执行一个“深拷贝”操作，但这不是强制的，如果你愿意，也可以在里面启动一个人工智能程序，都是有可能的。
6. 如果你确实需要Clone trait执行“深拷贝”操作，编译器帮我们提供了一个工具，我们可以在一个类型上添加``#[derive(Clone)]``，来让编译器帮我们自动生成那些重复的代码。
7. ``实现了Copy后, Clone含义也要符合Copy语义.``Rust语言规定了当T: Copy的情况下，Clone trait代表的含义。即：当某变量let t: T;，符合T: Copy时， 它调用 let x = t.clone() 方法的时候，它的含义必须等同于“简单内存拷贝”。也就是说，clone的行为必须等同于let x = std::ptr::read(&t);，也等同于let x = t;。当T: Copy时，我们不要在Clone trait里面乱写自己的逻辑。所以，当我们需要指定一个类型是 Copy 的时候，最好顺便也指定它 Clone 的行为，就是编译器为我们自动生成的那个逻辑。正因为如此，在希望让一个类型具有 Copy 性质的时候，一般使用 ``#[derive(Copy, Clone)]`` 这种方式，这种情况下它们俩最好一起出现，避免手工实现 Clone 导致错误


>因为``move``语义,Copy只是``简单内存拷贝`` , Clone里面就有~~花活~~了. 即Copy与Clone的主要区别在于编译器处理, Copy是针对编译器的,而Clone是针对程序员处理``move``语义的.
当``T:Copy``时该泛型也要实现``T:Clone``. 